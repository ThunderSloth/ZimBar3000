<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, March 04, 2016, 11:18 PM -->
<!-- MuClient version 5.00 -->

<!-- Plugin "Medina_Mapper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Medina_Mapper"
   author="Zimbus"
   id="fa3bfe8d7c94e7e3f847d413"
   language="Lua"
   purpose="Graphically map medina and normalize directions"
   save_state="y"
   date_written="2019-11-14 23:17:25"
   requires="3.00"
   version="3.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>
<!--  Triggers  -->

<triggers>
<!--  Enter and Exit  -->
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]$"
   name="enter_medina"
   regexp="y"
   send_to="12"
   sequence="99"
  >
  <send>
  start_medina()
</send>
  </trigger>
   <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\[(?!(somewhere in an alleyway|.*(specialized|birthday|Discworld|achievement|first time|killed by|gains a level|Cpu|Machine|Reclaimed|Cleaning|joined the|now worshipping|now a member of).*)).*\]$"
   name="exit_medina"
   regexp="y"
   send_to="12"
   sequence="98"
  >
  <send>
	end_medina()</send>
  </trigger>
<!--  Medina Rooms  -->
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)This is a small winding alleyway\, and there are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_A"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("A", "%&lt;exits&gt;")
  move_room("A")
  print_medina("A")
  print_mob_text("A")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)Standing in an alleyway\, surrounded by buildings and other alleys\, your head spins as you struggle to get your bearings\.  You fail miserably\.  Alleys lead in several directions\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_B"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("B", "%&lt;exits&gt;")
  move_room("B")
  print_medina("B")
  print_mob_text("B")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)The alleyway gets very narrow here\. There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_C"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("C", "%&lt;exits&gt;")
  move_room("C")
  print_medina("C")
  print_mob_text("C")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)This is a small winding alleyway with a T\-junction\.  All three possible exits look very similar and very alley\-ly\.  The alleys are narrow\, winding and difficult to navigate safely without a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_D"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("D", "%&lt;exits&gt;")
  move_room("D")
  print_medina("D")
  print_mob_text("D")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are five obvious exits\:(?!(.*enter door\.)).*|There are six obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_E"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("E", "%&lt;exits&gt;")
  move_room("E")
  print_medina("E")
  print_mob_text("E")
   </send>
  </trigger>
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)This is a cross alleyways\.  Like a cross\-roads\, but with alleyways\.  They go this way and that\.  You can\'t work out which way is north and you wish you\'d brought a compass\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_F"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("F", "%&lt;exits&gt;")
  move_room("F")
  print_medina("F")
  print_mob_text("F")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)At least at this point in the maze your decision is simple\.  Either go that way\, or that way\.  The alleyway simply bends here\, and you can continue or go back\.  It\'s entirely up to you\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_G"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("G", "%&lt;exits&gt;")
  move_room("G")
  print_medina("G")
  print_mob_text("G")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are three obvious exits\:(?!(.*enter door\.)).*|There are four obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_H_or_N"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  if room_sequence[1] then
	if room_sequence[1]:match("[ILDH]") then
		log_exits("H", "%&lt;exits&gt;")
		move_room("H")
		print_medina("H")
        print_mob_text("H")
	else
		log_exits("N", "%&lt;exits&gt;")
		move_room("N")
		print_medina("N")
        print_mob_text("N")
	end
  end
  
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)In the heart of the Red Triangle maze\, alleys lead in all directions\, and you are unsure which way to turn\.  Six alleys meet here\, or possibly\, depending on your point of view leave from here\.  Either way\, there are a lot of possible exits\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_I"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("I", "%&lt;exits&gt;")
  move_room("I")
  print_medina("I")
  print_mob_text("I")
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)Three alleyways merge here\.  They all look the same\, and all go in different directions\.  Small buildings line the alleyways\.  The exit ahead of you looks familiar\, or does it\?\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_J"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("J", "%&lt;exits&gt;")
  move_room("J")
  print_medina("J")
  print_mob_text("J")
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)Isn\'t this the same place you were in 5 minutes ago\?  Maybe not\.  But perhaps it is\, who knows\?  The alleyway bends here and you have a choice of two identical exits\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_K"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("K", "%&lt;exits&gt;")
  move_room("K")
  print_medina("K")
  print_mob_text("K")
  </send>
 </trigger>
 <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)As an Empire the Aurient is complex and easy to get lost in\.  This set of alleyways could easily be a metaphor for the whole of Agatea\.  They are complex and\, you\'ve guessed it\, easy to get lost in\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_L"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("L", "%&lt;exits&gt;")
  move_room("L")
  print_medina("L")
  print_mob_text("L")
  </send>
  </trigger>
<trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are four obvious exits\:(?!(.*enter door\.)).*|There are five obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_M"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("M", "%&lt;exits&gt;")
  move_room("M")
  print_medina("M")
  print_mob_text("M")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are two obvious exits\:(?!(.*enter door\.)).*|There are three obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_O"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("O", "%&lt;exits&gt;")
  move_room("O")
  print_medina("O")
  print_mob_text("O")
  </send>
  </trigger>
<trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The alley leads north and south\.  Or is it east and west\?  You are completely unsure\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_P"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("P", "%&lt;exits&gt;")
  move_room("P")
  print_medina("P")
  print_mob_text("P")
  </send>
  </trigger>
<trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)The alleys twist and turn\, until you eventually arrive here\.  Here is nowhere special\, just another junction within the maze of alleys in the Red Triangle\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="room_Q"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("Q", "%&lt;exits&gt;")
  move_room("Q")
  print_medina("Q")
  print_mob_text("Q")
   </send>
  </trigger>
<trigger
   enabled="y"
   group="medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^\[somewhere in an alleyway\]\n(.*\n|)This is a small winding alleyway\, dark and with other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="Room_R"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  log_exits("R", "%&lt;exits&gt;")
  move_room("R")
  process_elimination("R")
  print_medina("R")
  print_mob_text("R")
  </send>
  </trigger>  
<!--  Look on Medina Rooms  -->
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nThis is a small winding alleyway\, and there are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_A"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("A", "%&lt;exits&gt;")
	look_room("A")
	print_medina(room_sequence[1], "A")
  </send>
  </trigger>
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nStanding in an alleyway\, surrounded by buildings and other alleys\, your head spins as you struggle to get your bearings\.  You fail miserably\.  Alleys lead in several directions\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_B"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("B", "%&lt;exits&gt;")
	look_room("B")
	print_medina(room_sequence[1], "B")
  </send>
  </trigger>
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nThe alleyway gets very narrow here\. There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_C"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("C", "%&lt;exits&gt;")
	look_room("C")
	print_medina(room_sequence[1], "C")
  </send>
  </trigger>
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nThis is a small winding alleyway with a T\-junction\.  All three possible exits look very similar and very alley\-ly\.  The alleys are narrow\, winding and difficult to navigate safely without a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_D"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("D", "%&lt;exits&gt;")
	look_room("D")
	print_medina(room_sequence[1], "D")
  </send>
  </trigger>
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nYou are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are five obvious exits\:(?!(.*enter door\.)).*|There are six obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_E"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("E", "%&lt;exits&gt;")
	look_room("E")
	print_medina(room_sequence[1], "E")
  </send>
  </trigger>
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nThis is a cross alleyways\.  Like a cross\-roads\, but with alleyways\.  They go this way and that\.  You can\'t work out which way is north and you wish you\'d brought a compass\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_F"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("F", "%&lt;exits&gt;")
	look_room("F")
	print_medina(room_sequence[1], "F")
  </send>
  </trigger>
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nAt least at this point in the maze your decision is simple\.  Either go that way\, or that way\.  The alleyway simply bends here\, and you can continue or go back\.  It\'s entirely up to you\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_G"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("G", "%&lt;exits&gt;")
	look_room("G")
	print_medina(room_sequence[1], "G")
  </send>
  </trigger>
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nYou are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are three obvious exits\:(?!(.*enter door\.)).*|There are four obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_H_or_N"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
  if room_sequence[1] then
	if room_sequence[1]:match("[ILD]") then
			log_look_exits("H", "%&lt;exits&gt;")
			look_room("H")
			print_medina(room_sequence[1], "H")
	else
			log_look_exits("N", "%&lt;exits&gt;")
			look_room("N")
			print_medina(room_sequence[1], "N")
	end
  end
  </send>
  </trigger>
    <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nIn the heart of the Red Triangle maze\, alleys lead in all directions\, and you are unsure which way to turn\.  Six alleys meet here\, or possibly\, depending on your point of view leave from here\.  Either way\, there are a lot of possible exits\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_I"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("I", "%&lt;exits&gt;")
	look_room("I")
	print_medina(room_sequence[1], "I")
  </send>
  </trigger>
    <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nThree alleyways merge here\.  They all look the same\, and all go in different directions\.  Small buildings line the alleyways\.  The exit ahead of you looks familiar\, or does it\?\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_J"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("J", "%&lt;exits&gt;")
	look_room("J")
	print_medina(room_sequence[1], "J")
  </send>
  </trigger>
    <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nIsn\'t this the same place you were in 5 minutes ago\?  Maybe not\.  But perhaps it is\, who knows\?  The alleyway bends here and you have a choice of two identical exits\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_K"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("K", "%&lt;exits&gt;")
	look_room("K")
	print_medina(room_sequence[1], "K")
  </send>
 </trigger>
 <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nAs an Empire the Aurient is complex and easy to get lost in\.  This set of alleyways could easily be a metaphor for the whole of Agatea\.  They are complex and\, you\'ve guessed it\, easy to get lost in\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_L"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("L", "%&lt;exits&gt;")
	look_room("L")
	print_medina(room_sequence[1], "L")
  </send>
  </trigger>
<trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nYou are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are four obvious exits\:(?!(.*enter door\.)).*|There are five obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_M"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("M", "%&lt;exits&gt;")
	look_room("M")
	print_medina(room_sequence[1], "M")
  </send>
  </trigger>
  <trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nYou are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are two obvious exits\:(?!(.*enter door\.)).*|There are three obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_O"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("O", "%&lt;exits&gt;")
	look_room("O")
	print_medina(room_sequence[1], "O")
  </send>
  </trigger>
<trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nYou are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The alley leads north and south\.  Or is it east and west\?  You are completely unsure\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_P"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("P", "%&lt;exits&gt;")
	look_room("P")
	print_medina(room_sequence[1], "P")
  </send>
  </trigger>
<trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nThe alleys twist and turn\, until you eventually arrive here\.  Here is nowhere special\, just another junction within the maze of alleys in the Red Triangle\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_Q"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("Q", "%&lt;exits&gt;")
	look_room("Q")
	print_medina(room_sequence[1], "Q")
  </send>
  </trigger>
<trigger
   group="look_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nThis is a small winding alleyway\, dark and with other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="look_room_R"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	log_look_exits("R", "%&lt;exits&gt;")
	look_room("R")
	print_medina(room_sequence[1], "R")
  </send>
  </trigger>
  <!--  Scry Medina Room  -->
    <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)This is a small winding alleyway\, and there are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_A"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "A")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)Standing in an alleyway\, surrounded by buildings and other alleys\, your head spins as you struggle to get your bearings\.  You fail miserably\.  Alleys lead in several directions\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_B"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "B")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)The alleyway gets very narrow here\. There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_C"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "C")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)This is a small winding alleyway with a T\-junction\.  All three possible exits look very similar and very alley\-ly\.  The alleys are narrow\, winding and difficult to navigate safely without a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_D"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "D")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are five obvious exits\:(?!(.*enter door\.)).*|There are six obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_E"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "E")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)This is a cross alleyways\.  Like a cross\-roads\, but with alleyways\.  They go this way and that\.  You can\'t work out which way is north and you wish you\'d brought a compass\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_F"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "F")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)At least at this point in the maze your decision is simple\.  Either go that way\, or that way\.  The alleyway simply bends here\, and you can continue or go back\.  It\'s entirely up to you\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_G"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "G")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are three obvious exits\:(?!(.*enter door\.)).*|There are four obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_H_or_N"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	local exits = "%&lt;exits&gt;"
	local temp_exits = {} -- create a set of exits
	if exits:match(" north[%s%.,]") then temp_exits.n = true end
	if exits:match(" northeast[%s%.,]") then temp_exits.ne = true end
	if exits:match(" east[%s%.,]") then temp_exits.e = true end
	if exits:match(" southeast[%s%.,]") then temp_exits.se = true end
	if exits:match(" south[%s%.,]") then temp_exits.s = true end
	if exits:match(" southwest[%s%.,]") then temp_exits.sw = true end
	if exits:match(" west[%s%.,]") then temp_exits.w = true end
	if exits:match(" northwest[%s%.,]") then temp_exits.nw = true end
	
	local function H_or_N(temp_exits)
		local match = true
		if med_rooms.H.exits and med_rooms.N.exits then
			for k, v in pairs(med_rooms.H.exits) do
				if not(med_rooms.N.exits[k]) then
					match = false
					break
				end
			end
			if match then 
				return("H or N")
			end
		end
		match = true
		if med_rooms.H.exits then
			for k, v in pairs(med_rooms.H.exits) do
				if not(temp_exits[k]) then
					match = false
					break
				end
			end
			if match then
				return("H")
			else
				return("N")
			end
		elseif med_rooms.N.exits then
			for k, v in pairs(med_rooms.N.exits) do
				if not(temp_exits[k]) then
					match = false
					break
				end
			end
			if match then
				return("N")
			else
				return("H")
			end	
		else
			return("H or N")
		end
	end
	print_medina(room_sequence[1], H_or_N(temp_exits))
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)In the heart of the Red Triangle maze\, alleys lead in all directions\, and you are unsure which way to turn\.  Six alleys meet here\, or possibly\, depending on your point of view leave from here\.  Either way\, there are a lot of possible exits\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_I"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "I")
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)Three alleyways merge here\.  They all look the same\, and all go in different directions\.  Small buildings line the alleyways\.  The exit ahead of you looks familiar\, or does it\?\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_J"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "J")
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)Isn\'t this the same place you were in 5 minutes ago\?  Maybe not\.  But perhaps it is\, who knows\?  The alleyway bends here and you have a choice of two identical exits\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_K"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "K")
  </send>
 </trigger>
 <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)As an Empire the Aurient is complex and easy to get lost in\.  This set of alleyways could easily be a metaphor for the whole of Agatea\.  They are complex and\, you\'ve guessed it\, easy to get lost in\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_L"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "L")
  </send>
  </trigger>
<trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are four obvious exits\:(?!(.*enter door\.)).*|There are five obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_M"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "M")
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are two obvious exits\:(?!(.*enter door\.)).*|There are three obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_O"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "O")
  </send>
  </trigger>
<trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The alley leads north and south\.  Or is it east and west\?  You are completely unsure\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_P"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "P")
  </send>
  </trigger>
<trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)The alleys twist and turn\, until you eventually arrive here\.  Here is nowhere special\, just another junction within the maze of alleys in the Red Triangle\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_Q"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "Q")
  </send>
  </trigger>
<trigger
   enabled="y"
   group="scry_medina_rooms"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!\[somewhere in an alleyway\])((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.)\n(.*\n|)This is a small winding alleyway\, dark and with other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   name="scry_room_R"
   regexp="y"
   send_to="12"
   sequence="100"
  ><send>
	print_medina(room_sequence[1], "R")
  </send>
  </trigger>
  <!--  Track Mobs  -->
  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*This is a small winding alleyway\, and there are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y" 
   name="mob_A"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "A", true)
      print_mob_text("A", true)
   </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*Standing in an alleyway\, surrounded by buildings and other alleys\, your head spins as you struggle to get your bearings\.  You fail miserably\.  Alleys lead in several directions\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_B"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "B", true)
      print_mob_text("B", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*The alleyway gets very narrow here\. There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_C"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "C", true)
      print_mob_text("C", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*This is a small winding alleyway with a T\-junction\.  All three possible exits look very similar and very alley\-ly\.  The alleys are narrow\, winding and difficult to navigate safely without a map\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_D"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "D", true)
      print_mob_text("D", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n.*\n.*(There are five obvious exits\:(?!(.*enter door\.)).*|There are six obvious exits\:.*enter door\.)\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_E"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "E", true)
      print_mob_text("E", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*This is a cross alleyways\.  Like a cross\-roads\, but with alleyways\.  They go this way and that\.  You can\'t work out which way is north and you wish you\'d brought a compass\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_F"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "F", true)
      print_mob_text("F", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*At least at this point in the maze your decision is simple\.  Either go that way\, or that way\.  The alleyway simply bends here\, and you can continue or go back\.  It\'s entirely up to you\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_G"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "G", true)
      print_mob_text("G", true)
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n.*\n.*(?P&lt;exits&gt;There are three obvious exits\:(?!(.*enter door\.)).*|There are four obvious exits\:.*enter door\.)\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_H_or_N"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
	local exits = "%&lt;exits&gt;"
	local temp_exits = {} -- create a set of exits
	if exits:match(" north[%s%.,]") then temp_exits.n = true end
	if exits:match(" northeast[%s%.,]") then temp_exits.ne = true end
	if exits:match(" east[%s%.,]") then temp_exits.e = true end
	if exits:match(" southeast[%s%.,]") then temp_exits.se = true end
	if exits:match(" south[%s%.,]") then temp_exits.s = true end
	if exits:match(" southwest[%s%.,]") then temp_exits.sw = true end
	if exits:match(" west[%s%.,]") then temp_exits.w = true end
	if exits:match(" northwest[%s%.,]") then temp_exits.nw = true end
	
	local function H_or_N(temp_exits)
		local match = true
		if med_rooms.H.exits and med_rooms.N.exits then
			for k, v in pairs(med_rooms.H.exits) do
				if not(med_rooms.N.exits[k]) then
					match = false
					break
				end
			end
			if match then 
				return("H or N")
			end
		end
		match = true
		if med_rooms.H.exits then
			for k, v in pairs(med_rooms.H.exits) do
				if not(temp_exits[k]) then
					match = false
					break
				end
			end
			if match then
				return("H")
			else
				return("N")
			end
		elseif med_rooms.N.exits then
			for k, v in pairs(med_rooms.N.exits) do
				if not(temp_exits[k]) then
					match = false
					break
				end
			end
			if match then
				return("N")
			else
				return("H")
			end	
		else
			return("H or N")
		end
	end
    local rm = H_or_N(temp_exits)
    get_mobs("%&lt;mobs&gt;", rm, true)
    if rm == ("H or N") then
         print_mob_text("H", true)
         print_mob_text("N", true)
    else
         print_mob_text(rm, true)
    end
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*In the heart of the Red Triangle maze\, alleys lead in all directions\, and you are unsure which way to turn\.  Six alleys meet here\, or possibly\, depending on your point of view leave from here\.  Either way\, there are a lot of possible exits\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_I"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "I", true)
      print_mob_text("I", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*Three alleyways merge here\.  They all look the same\, and all go in different directions\.  Small buildings line the alleyways\.  The exit ahead of you looks familiar\, or does it\?\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_J"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "J", true)
      print_mob_text("J", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*Isn\'t this the same place you were in 5 minutes ago\?  Maybe not\.  But perhaps it is\, who knows\?  The alleyway bends here and you have a choice of two identical exits\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_K"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "K", true)
      print_mob_text("K", true)
  </send>
  </trigger>
    <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*As an Empire the Aurient is complex and easy to get lost in\.  This set of alleyways could easily be a metaphor for the whole of Agatea\.  They are complex and\, you\'ve guessed it\, easy to get lost in\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_L"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "L", true)
      print_mob_text("L", true)
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n.*\n.*(There are four obvious exits\:(?!(.*enter door\.)).*|There are five obvious exits\:.*enter door\.)\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_M"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "M", true)
      print_mob_text("M", true)
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n.*\n.*(There are two obvious exits\:(?!(.*enter door\.)).*|There are three obvious exits\:.*enter door\.)\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_O"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "O", true)
      print_mob_text("O", true)
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*You are standing in a small winding alleyway\.  There are other alleys leading off it\.  They are all small and winding too\.  The alley leads north and south\.  Or is it east and west\?  You are completely unsure\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_P"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "P", true)
      print_mob_text("P", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*The alleys twist and turn\, until you eventually arrive here\.  Here is nowhere special\, just another junction within the maze of alleys in the Red Triangle\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_Q"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "Q", true)
      print_mob_text("Q", true)
  </send>
  </trigger>

  <trigger
   enabled="y"
   group="mob_tracking"
   lines_to_match="4"
   keep_evaluating="y"
   match=".*This is a small winding alleyway\, dark and with other alleys leading off it\.  They are all small and winding too\.  The walls are too high to see over\, and buildings block your view in all directions\.  A person could easily get lost in here unless they had a good memory\, or a map\.\n.*\nThere are .* obvious exits\:.*\n(?P&lt;mobs&gt;.+)\Z"
   multi_line="y"
   name="mob_R"
   regexp="y"
   send_to="12"
   sequence="10"
  ><send>
      get_mobs("%&lt;mobs&gt;", "R", true)
      print_mob_text("R", true)
  </send>
  </trigger>
      <trigger
   keep_evaluating="y"
   group="medina_mapper"
   lines_to_match="2"
   match="^(?!There are .* obvious exits\:).*\n(?!   )(?P&lt;mobs&gt;.* (leaves?|stumbles? off to the) (?P&lt;directions&gt;north|northeast|east|southeast|south|southwest|west|northwest)\.)\Z"
   multi_line="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  	local direction = string.lower("%&lt;directions&gt;")
	direction = direction:gsub("north", "n")
	direction = direction:gsub("east", "e")
	direction = direction:gsub("south", "s")
	direction = direction:gsub("west", "w")
	
	move_dir = direction
    get_mobs("%&lt;mobs&gt;", room_sequence[1], false, direction)
	print_medina(room_sequence[1])
    print_mob_text(room_sequence[1], true)
  </send>
  </trigger>
      <trigger
   keep_evaluating="y"
   group="medina_mapper"
   lines_to_match="2"
   match="^(?!There are .* obvious exits\:).*\n(?!   )(?P&lt;mobs&gt;.* (stumbles? in from one of the alleys|arrives? from the \w+)\.)\Z"
   multi_line="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  move_dir = false
  get_mobs("%&lt;mobs&gt;", room_sequence[1], false)
  print_mob_text(room_sequence[1], true)
  </send>
  </trigger>
    <trigger
   keep_evaluating="y"
   group="medina_mapper"
   match="^(?P&lt;mobs&gt;.* succeeds? in following you\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  get_mobs("%&lt;mobs&gt;", room_sequence[1], false)
  </send>
  </trigger>
    <trigger
   keep_evaluating="y"
   group="medina_mapper"
   match="^(?P&lt;mobs&gt;.* follows? .* in\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  get_mobs("%&lt;mobs&gt;", room_sequence[1], false)
  print_mob_text(room_sequence[1], true)
  </send>
  </trigger>
        <trigger
   keep_evaluating="y"
   group="medina_mapper"
   match="^(?P&lt;mobs&gt;.* follows? .* out\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  get_mobs("%&lt;mobs&gt;", room_sequence[1], false)
  print_mob_text(room_sequence[1], true)
  </send>
  </trigger>
    <trigger
   group="medina_mapper"
   ignore_case="y"
   keep_evaluating="y"
   lines_to_match="2"
   match="(?!There are .* obvious exits\:).*\n(?P&lt;mobs&gt;.* emerges? from a thaumic door which appears in midair\.)\Z"
   multi_line="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  get_mobs("%&lt;mobs&gt;", room_sequence[1], false)
  print_mob_text(room_sequence[1], true)
  </send>
  </trigger>
    <trigger
   group="medina_mapper"
   keep_evaluating="y"
   lines_to_match="2"
   match="(?!There are .* obvious exits\:).*\n(?P&lt;mobs&gt;.* (kill|deals the death blow to) .*\.)\Z"
   multi_line="y"
   name="kill_mob"
   regexp="y"
   send_to="12"
   sequence="10"
  >
  <send>
  move_dir = false
  get_mobs("%&lt;mobs&gt;", room_sequence[1], false)
  print_mob_text(room_sequence[1], true)
  </send>
</trigger>
  <trigger
   group="medina_mapper"
   ignore_case="y"
   keep_evaluating="y"
   match="^(?P&lt;mobs&gt;.* moves? through the \w+ ((wire mesh|stone|crystal) door|piece of fur)\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  get_mobs("%&lt;mobs&gt;", room_sequence[1], false)
  print_mob_text(room_sequence[1], true)
 </send>
  </trigger>
  <trigger
   enabled="y"
   ignore_case="y"
   keep_evaluating="y"
   match="^Cannot find &quot;(Triad )?boss&quot;, no match\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
    local function table_length(T)
        local count = 0
        for _ in pairs(T) do count = count + 1 end
        return count
    end
    for k, v in pairs(med_rooms) do
        if v.mobs then
            if med_rooms[k].mobs["Triad boss"] then
                med_rooms[k].mobs["Triad boss"] = nil
            end
            if table_length(v.mobs) == 0 then
                med_rooms[k].mobs = false
            end
        end
    end
    if WindowInfo (win, 5) then
        print_medina()
    end
    </send>
  </trigger>
  <!--  Movement Tracking  -->
  
    <trigger
   group="medina_mapper"
   keep_evaluating="y"
   match="^(A bright red danger pictogram is on the side of a building.*|The Lover's Lane entrance to the Medina\.  It's dark here, isn't it\?|The middle of Ricecake Alley\.  It's dark here, isn't it\?|Cannot find \&quot;(n|ne|e|se|s|sw|w|nw|north|northeast|east|southeast|south|southwest|west|northwest)\&quot;, no match.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  table.remove(look_dir, 1)
  </send>
  </trigger>
  <trigger
   group="medina_mapper"
   keep_evaluating="y"
   match="^(That doesn't work\.|What\?|Try something else\.)$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
	table.remove(q_command, 1)
	table.remove(room_sequence, 2)
  </send>
  </trigger>
  <trigger
   keep_evaluating="y"
   group="medina_mapper"
   match="^You follow .* (north|northeast|east|southeast|south|southwest|west|northwest)\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
	command_count = (command_count or 0) + 1 -- keep track of commands entered so we can correctly clear tables when "stop" is entered
  
  	direction = string.lower("%1")
	direction = direction:gsub("north", "n")
	direction = direction:gsub("east", "e")
	direction = direction:gsub("south", "s")
	direction = direction:gsub("west", "w")
	
	table.insert(q_command, 1, direction)
	while(room_sequence[2]) do -- clears room sequence except current room
		table.remove(room_sequence, 2)
	end

	for i, v in ipairs(q_command) do
		if v ~= "l" then
			if room_sequence[#room_sequence] then
				if med_rooms[room_sequence[#room_sequence]].exits then 
					if med_rooms[room_sequence[#room_sequence]].exits[v] ~= nil then
						table.insert(room_sequence, med_rooms[room_sequence[#room_sequence]].exits[v].room) -- reconstruct room_sequence
					else
						table.insert(room_sequence, room_sequence[#room_sequence])
					end
				else
					table.insert(room_sequence, false)
				end
			else
				table.insert(room_sequence, false)
			end
		else
			table.insert(room_sequence, room_sequence[#room_sequence])
		end
	end
  </send>
  </trigger>
  <!--  Night-Vision  -->
      <trigger
   keep_evaluating="y"
   group="medina_mapper"
   lines_to_match="3"
   match="(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nIt's dark here, isn't it\?\n(?!There are (\w)+ obvious exits\:.*enter door\.).+\Z"
   multi_line="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
    if look_dir[1] then
	
		if med_rooms[room_sequence[1]].exits[look_dir[1]] then
			if med_rooms[room_sequence[1]].exits[look_dir[1]].room then
				print_medina(room_sequence[1], med_rooms[room_sequence[1]].exits[look_dir[1]].room)
			end
		end
		table.remove(look_dir, 1)
	end

  </send>
  </trigger>
      <trigger
   group="medina_mapper"
   lines_to_match="6"
   keep_evaluating="y"
   match="^(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\n(?!((The crystal ball changes to show a vision of the area where .* is|The image in the crystal ball fades, but quickly returns showing a new area|You see a vision in the .*|You look through the .* (door|fur)|You see a vision in the silver mirror|You see):|You focus past the .* baton, and visualise the place you remembered\.\.\.|You briefly see a vision\.|\[somewhere in an alleyway\])).*\nSomewhere in an alleyway\.  It's dark here\, isn't it\?\n(.*\n|)(.*\n|)(?P&lt;exits&gt;There are (\w)+ obvious exits\:(?!(.*enter door\.)).*|There are (\w)+ obvious exits\:.*enter door\.)\Z"
   multi_line="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  -- here is the code for "night-vision mapping", used when it is too dark to see room description by looking through exits
  -- instead we rely on the exit-list in order to determine the room we are looking at
	local exits = "%&lt;exits&gt;"
	local temp_exits = {} -- create a table containing the exit list of the exit we are looking at 
	if exits:match(" north[%s%.,]") then table.insert(temp_exits, "n") end
	if exits:match(" northeast[%s%.,]") then table.insert(temp_exits, "ne") end
	if exits:match(" east[%s%.,]") then table.insert(temp_exits, "e") end
	if exits:match(" southeast[%s%.,]") then table.insert(temp_exits, "se") end
	if exits:match(" south[%s%.,]") then table.insert(temp_exits, "s") end
	if exits:match(" southwest[%s%.,]") then table.insert(temp_exits, "sw") end
	if exits:match(" west[%s%.,]") then table.insert(temp_exits, "w") end
	if exits:match(" northwest[%s%.,]") then table.insert(temp_exits, "nw") end
	local function solve_exit(room) -- if we have enough info to determine the room we are looking at we will use this
		log_look_exits(room, exits)
		look_room(room)
		print_medina(room_sequence[1], room)
	end
	local function handle_exit_match()
		med_rooms[room_sequence[1]].exits[look_dir[1]].exits = {} 
		for i, v in ipairs(temp_exits) do -- first, we log the exits even though we can't determine (with certainty) which room we are looking at
			med_rooms[room_sequence[1]].exits[look_dir[1]].exits[v] = true
		end
		for k, _ in pairs(med_rooms[room_sequence[1]].exit_rooms) do -- iterate through adjacent rooms to see if the exit lists match
			local match, exn = true, 0
			if med_rooms[k].exits then
				for _1, _2 in pairs(med_rooms[k].exits) do
					exn = exn + 1
				end
				if exn == #temp_exits then -- make sure the number of exits match
					for i, v in ipairs(temp_exits) do
						if not(med_rooms[k].exits[v]) then -- make sure the exits match
							match = false
							break
						end
					end
					if match then
						log_look_exits(k, exits)
						look_room(k)
						local xrooms = {}
						for k2, v2 in pairs(med_rooms[room_sequence[1]].exits) do -- because we assume that no two exits from one room have identical exit-list we must now make sure this is the case (there is a slight possibility that it isn't)
							if v2.room then
								if xrooms[v2.room] then
									med_rooms[room_sequence[1]].normalized[med_rooms[room_sequence[1]].exit_rooms[v2.room]] = false
									for k3, v3 in pairs(med_rooms[room_sequence[1]].exits) do
										if v2.room == v3.room then
											med_rooms[room_sequence[1]].exits[k3].room = false
										end
									end
									med_rooms[room_sequence[1]].unlocked = false
									break
								else
									xrooms[v2.room] = true
								end
							end
						end
						break
					end
				end
			end
		end
		if med_rooms[room_sequence[1]].exits[look_dir[1]] then
			print_medina(room_sequence[1], med_rooms[room_sequence[1]].exits[look_dir[1]].room) -- notice we don't use solve_exit() here since we still had to check for duplicates
		else
			print_medina(room_sequence[1])
		end
		table.remove(look_dir, 1)
	end
	if #temp_exits == 6 then -- 6-exit room is always I (heart)
		solve_exit("I")
	elseif #temp_exits == 5 then -- 5-exit room is always E
		solve_exit("E")
	elseif #temp_exits == 4 then -- most rooms contain exits that each contain different amounts of exits, this alows us to determine the room we are looking at
		if room_sequence[1] == "B" then
			solve_exit("A")
		elseif room_sequence[1] == "C" then
			solve_exit("F")
		elseif room_sequence[1] == "D" then
			solve_exit("A")
		elseif room_sequence[1] == "G" then
			solve_exit("F")
		elseif room_sequence[1] == "H" then
			solve_exit("L")
		elseif room_sequence[1] == "L" then
			solve_exit("M")
		elseif room_sequence[1] == "M" then
			solve_exit("L")
		elseif room_sequence[1] == "N" then
			solve_exit("M")
		elseif room_sequence[1] == "O" then
			solve_exit("L")
		elseif room_sequence[1] == "P" then
			solve_exit("M")
		elseif med_rooms[room_sequence[1]].exits[look_dir[1]].room then -- if we already have the info of which room we are looking at, but can't confirm then we will print the map useing data we have previously collected
			solve_exit(med_rooms[room_sequence[1]].exits[look_dir[1]].room)
		else
			handle_exit_match()
		end
	elseif #temp_exits == 3 then
		if room_sequence[1] == "C" then
			solve_exit("B")
		elseif room_sequence[1] == "D" then
			solve_exit("H")
		elseif room_sequence[1] == "H" then
			solve_exit("D")
		elseif room_sequence[1] == "J" then
			solve_exit("N")
		elseif room_sequence[1] == "K" then
			solve_exit("J")
		elseif room_sequence[1] == "L" then
			solve_exit("H")
		elseif room_sequence[1] == "O" then
			solve_exit("P")
		elseif room_sequence[1] == "P" then
			solve_exit("Q")
		elseif room_sequence[1] == "R" then
			solve_exit("Q")
		elseif med_rooms[room_sequence[1]].exits[look_dir[1]].room then
			solve_exit(med_rooms[room_sequence[1]].exits[look_dir[1]].room)
		else
			handle_exit_match()
		end
	elseif #temp_exits == 2 then
		if room_sequence[1] == "B" then
			solve_exit("C")
		elseif room_sequence[1] == "G" then
			solve_exit("K")
		elseif room_sequence[1] == "J" then
			solve_exit("K")
		elseif room_sequence[1] == "K" then
			solve_exit("G")
		elseif room_sequence[1] == "L" then
			solve_exit("O")
		elseif room_sequence[1] == "P" then
			solve_exit("O")
		elseif room_sequence[1] == "Q" then
			solve_exit("R")
		elseif med_rooms[room_sequence[1]].exits[look_dir[1]].room then
			solve_exit(med_rooms[room_sequence[1]].exits[look_dir[1]].room)
		else
			handle_exit_match()
		end
	end
  </send>
  </trigger>
    <!--  Stop Handling  -->
  <trigger
   group="medina_mapper"
   keep_evaluating="y"
   match="^Removed queue\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  -- we can't just clear the tables entirely because commands may have been entered after "stop"
  while(look_dir[(look_count + 1)]) do
	table.remove(look_dir, (look_count + 1))
  end
  while(q_command[(command_count + 1)] ~= nil) do
	table.remove(q_command, (command_count + 1))
  end
  while(room_sequence[(command_count + 2)]) do
	table.remove(room_sequence, (command_count + 2))
  end
  print_medina(room_sequence[1] or false)
  </send>
  </trigger>
<!--  Print Map on Bury  -->
  <trigger
   group="medina_mapper"
   keep_evaluating="y"
   match=".* bur(y|ies) .* deep within the earth\.$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
--print_medina(room_sequence[1])
  </send>
  </trigger>
    <!--  Sync  -->
  <trigger
   name="get_sync"
   keep_evaluating="y"
   lines_to_match="2"
   match="^(?!\*\*.*).*\n([A-z]+)( .*)? tells you: v([0-9.]+)(([A-R]=([NESW][ew]?[NESWF][ew]?)+){18})([0-9.]+)?[A-R]?$"
   multi_line="y"
   enabled="y"
   omit_from_output="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
sync_table, time_created = accept_sync(parse_sync_text("%1","%3","%4","%7"))
  </send>
  </trigger>
</triggers>
<!--  Aliases  -->

<aliases>
<alias
   group="medina_mapper"
   name="look_room"
   match="^l(ook)? (n|ne|e|se|s|sw|w|nw|north|northeast|east|southeast|south|southwest|west|northwest)$"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
	look_count = (look_count or 0) + 1
  
	direction = string.lower("%2")
	direction = direction:gsub("north", "n")
	direction = direction:gsub("east", "e")
	direction = direction:gsub("south", "s")
	direction = direction:gsub("west", "w")
	
	if med_rooms[room_sequence[#room_sequence]].unlocked then -- unlike movement look-directions only normalize after all exits in the room are unlocked
		if med_rooms[room_sequence[#room_sequence]].normalized[direction] then
			Send("l "..med_rooms[room_sequence[#room_sequence]].normalized[direction])
			table.insert(look_dir, med_rooms[room_sequence[#room_sequence]].normalized[direction])
		else
			Send("l "..direction)
			table.insert(look_dir, direction)
		end
	else
		Send("l "..direction)
		table.insert(look_dir, direction)
	end

</send>
  </alias>
  <alias
   group="medina_mapper"
   name="movement_tracker"
   match="^(n|ne|e|se|s|sw|w|nw|north|northeast|east|southeast|south|southwest|west|northwest|look|l)$"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
    Send(handle_movement("%1"))
    print_medina(room_sequence[1])
    
</send>
  </alias>
<alias
   group="medina_mapper"
   name="drag_corpse_tracker"
   match="^(drag corpse |dc )(n|ne|e|se|s|sw|w|nw|north|northeast|east|southeast|south|southwest|west|northwest)$"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
    Send("drag corpse "..handle_movement("%2"))
    print_medina(room_sequence[1])  
</send>
  </alias>
    <alias
   group="medina_mapper"
   name="abscond_tracker"
   match="^(abscond |abs?[1-3]? )(n|ne|e|se|s|sw|w|nw|north|northeast|east|southeast|south|southwest|west|northwest)$"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
    --This alias will capture most commonly used abscond aliases: abscond, ab, abs, abs1 ect..
    --It will always output 'abscond [direction]' without any other arguments unless you customize it to do so
    --Contact me If you would like help doing so
    Send("abscond "..handle_movement("%2"))
    print_medina(room_sequence[1])  
</send>
  </alias>
     <alias
   group="medina_mapper"
   name="stop"
   match="^stop$"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
  command_count = 0
  look_count = 0
  Send("stop")
</send>
  </alias>
<alias
   name="medina_reset"
   match="^med(ina)? ?r(eset|s)? ?(r)?(oom)? ?([A-Ra-r])?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if "%5" ~= "" then
      local room = ("%5"):upper()
      if room == room_sequence[1] then
            reset_room(room_sequence[1])
            ColourNote("gray", "black", "Medina room reset.")
            Send("l")
      else
            reset_room(room)
            ColourNote("gray", "black", "Medina room: "..room.." reset.")
      end
elseif "%3" ~= "" then
      if room_sequence[1] then
            reset_room(room_sequence[1])
            ColourNote("gray", "black", "Medina room reset.")
            Send("l")
      end
else
      load_med_rooms()
      local tl = GetTimerList ()
      if tl then
        for k, v in ipairs(tl) do 
          DeleteTimer(v)
        end
      end
      ColourNote("gray", "black", "Medina reset.")
      if room_sequence[1] then
            Send("l")
      end
end
  print_medina(room_sequence[1] or false)
  </send>
</alias>
    <alias
   name="medina_table"
   match="^med(ina)? ?ta?(ab(le)?|bl?)( (?P&lt;room&gt;[A-Ra-r]))?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
  if "%&lt;room&gt;" ~= "" then
    Note(string.upper("%&lt;room&gt;:"))
    tprint(med_rooms[string.upper("%&lt;room&gt;")])
  else
    Note("med_rooms:");if med_rooms then tprint(med_rooms) else Note("nil") end
  end
  Note("q_commands:");if q_commands then tprint(q_command) else Note("nil") end
  Note("room_sequence:");if room_sequence then tprint(room_sequence) else Note("nil") end
</send>
  </alias>
    <alias
   name="medina_timer"
   match="^med(ina)? ?t(im?e?r?|mr?|r)$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
tl = GetTimerList ()
if tl then
  Note("Timers:")
  for k, v in ipairs (tl) do 
    local h, m, s = time_units(GetTimerInfo(v, 13))
    Note(v,": h=",h," m=",m," s=",s)
  end
else
   Note("No timers.")   
end
</send>
  </alias>
    <alias
   name="medina_sync"
   match="^med(ina)? ?s(ync)? ?(.*)?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if "%3" == "" then
    if sync_table then
        apply_sync(sync_table, time_created)
    else
        ColourNote(
           "white", "black", "&lt;",
           "red", "black", "No current sync data!",
           "white", "black", "&gt;"
            )
    end
else
   Send("tell %3 ",get_sync_text(med_rooms))
end
</send>
  </alias>
        <alias
   name="medina_help"
   match="^med(ina)? ?h(e?lp)?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
medina_help(GetPluginInfo (GetPluginID (), 19))
</send>
  </alias>
<alias
   name="medina_view"
   match="^med(ina)? ?v(iew)?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
print_medina()
</send>
  </alias>
<alias
   name="medina_exit"
   match="^med(ina)? ?e?x?(it)?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
WindowShow(win, false)	
</send>
  </alias>
<alias
   name="medina_config"
   match="^med(ina)? ?c(onfig(ure)?)?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
Send("options output look=verbose")
</send>
  </alias>
<alias
   name="medina_fix"
   match="^med(ina)? ?f(ix?)?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
	look_dir = {}	
	q_command = {}
    local rs = room_sequence[1]
	room_sequence = {}
    table.insert(room_sequence, rs)
</send>
  </alias>
<alias
   name="medina_boss_to_group"
   match="^med(ina)? ?b(oss?)?$"
   enabled="y"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
boss_to_group()
</send>
  </alias>
</aliases>

<!--  Script  -->

<script>
<![CDATA[
--------------------------------------------------------------------------------
--   Help File
--------------------------------------------------------------------------------
function medina_help(version)
local optional, command, argument, dash, bracket, description = "gray", "yellow", "yellow", "gray", "white", "gray"
Note();ColourNote("white","black","<","yellow","black","Medina Mapper ","gray","black","v","white","black",string.format("%.2f",version),"gray","black"," by ","yellow","black","Zimbus","white","black",">")
Note();ColourNote(command,"black"," med",optional,"black","ina ",command,"black","h",optional,"black","elp ",dash,"black","................. ",description,"black","this helpfile")
ColourNote(command,"black"," med",optional,"black","ina ",command,"black","c",optional,"black","onfig ",dash,"black","............... ",description,"black","run compatability configurations")
Note();ColourNote(command,"black"," med",optional,"black","ina ",command,"black","s",optional,"black","ync ",dash,"black","................. ",description,"black","update map using recieved data ")
ColourNote(command,"black"," med",optional,"black","ina ",command,"black","s",optional,"black","ync ",bracket,"black","<",argument,"black","player",bracket,"black","> ",dash,"black","........ ",description,"black","send map data")
Note();ColourNote(command,"black"," med",optional,"black","ina ",command,"black","r",optional,"black","eset ",dash,"black","................ ",description,"black","reset map data")
ColourNote(command,"black"," med",optional,"black","ina ",command,"black","r",optional,"black","eset ",command,"black","r",optional,"black","oom ",dash,"black","........... ",description,"black","reset current room")
ColourNote(command,"black"," med",optional,"black","ina ",command,"black","r",optional,"black","eset ",command,"black","r",optional,"black","oom ",bracket,"black","<",argument,"black","letter",bracket,"black","> ",dash,"black",".. ",description,"black","reset specific room")
Note();ColourNote(command,"black"," med",optional,"black","ina ",command,"black","f",optional,"black","ix ",dash,"black",".................. ",description,"black","fix bugged normalization")
Note();ColourNote(command,"black"," med",optional,"black","ina ",command,"black","v",optional,"black","iew ",dash,"black","................. ",description,"black","show map window")
ColourNote(command,"black"," med",optional,"black","ina ",optional,"black","e",command,"black","x",optional,"black","it ",dash,"black","................. ",description,"black","close map window");Note()
ColourNote(command,"black"," med",optional,"black","ina ",command,"black","b",optional,"black","oss ",dash,"black","................. ",description,"black","print");Note()
ColourNote(bracket,"black","*", description, "black", "spaces and gray text optional");Note()
end
--------------------------------------------------------------------------------
--   START AND END MAP
--------------------------------------------------------------------------------
function start_medina()
	look_dir = {}	
	q_command = {}
	room_sequence = {}
    previous_room = false
	
	EnableTrigger("enter_medina", false)
	EnableTrigger("exit_medina", true)
	EnableGroup("medina_mapper", true)
	EnableGroup("look_medina_rooms", true)

    DeleteTimer("clear_mobs")
end

function end_medina()
	room_sequence = {}

	EnableTrigger("enter_medina", true)
	EnableTrigger("exit_medina", false)
	EnableGroup("medina_mapper", false)
	EnableGroup("look_medina_rooms", false)
    WindowShow(win, false)	
    AddTimer ("clear_mobs", 0, 5, 0, "", timer_flag.Enabled + timer_flag.Replace + timer_flag.Temporary + timer_flag.OneShot, "clear_mobs")
end
--------------------------------------------------------------------------------
--  MOVEMENT HANDLING
--------------------------------------------------------------------------------
function handle_movement(dir)
  command_count = (command_count or 0) + 1
  
	direction = string.lower(dir)
	direction = direction:gsub("north", "n")
	direction = direction:gsub("east", "e")
	direction = direction:gsub("south", "s")
	direction = direction:gsub("west", "w")
	
	if direction:match("l") then
        table.insert(q_command, "l")
		table.insert(room_sequence, room_sequence[#room_sequence])
        return "l"
	elseif room_sequence[#room_sequence] then
		if med_rooms[room_sequence[#room_sequence]].normalized[direction] then -- we are normalizing directions based on the room_sequence table, this keeps track of your queued trajectory
			dir = med_rooms[room_sequence[#room_sequence]].normalized[direction]
			table.insert(q_command, med_rooms[room_sequence[#room_sequence]].normalized[direction])
            if med_rooms[room_sequence[#room_sequence]].exits then
                table.insert(room_sequence, med_rooms[room_sequence[#room_sequence]].exits[med_rooms[room_sequence[#room_sequence]].normalized[direction]].room)
		    else
                table.insert(room_sequence, false)
            end
            return dir
        else
            table.insert(q_command, direction)
			table.insert(room_sequence, false)
            return direction
		end
	else
        table.insert(q_command, direction)
		table.insert(room_sequence, false)
        return direction
	end
end
--------------------------------------------------------------------------------
--  SYNC FUNCTIONS
--------------------------------------------------------------------------------
function get_sync_text(tbl)
    local text, time, i = "v"..GetPluginInfo (GetPluginID (), 19), 0, 0 -- version, time, count
    for room, v in pairs(tbl) do
        text = text..room.."="
        for static, temp in pairs(v.normalized) do
            text = text..(static:gsub("^%l", string.upper))
            if temp then
                text = text..(temp:gsub("^%l", string.upper))
            else
                text = text.."F"
            end
        end
        if v.unlocked then
            time = time+v.unlocked
            i = i + 1
        end
    end
    if i ~= 0 then
        text = text..tostring(time/i)
    end
    return text
end

function parse_sync_text(name, version, text, time)
     text=text:gsub("([A-R]=)", " %0").." "
     local tbl = {}
     for k, v in string.gmatch(text, "(%w)=(%w+) ") do
        tbl[k] = {}
        for static, temp in string.gmatch(v, "([A-Z][a-z]?)([A-Z][a-z]?)") do
            if temp == "F" then 
                temp = false 
            else 
                temp = temp:gsub("%w+", string.lower) 
            end
            tbl[k][static:gsub("%w+", string.lower)] = temp
        end
    end
    local count = 0
    for _, v in pairs(tbl) do
        local unlocked = true
        for _2, temp in pairs(v) do
            if not(temp) then unlocked = false; break; end
        end
        if unlocked then count = count + 1 end
    end
    return tbl, count, name, version, time
end

function accept_sync(tbl, count, name, version, time)
    local percent, t =  (math.floor((count/18) *10000 + 0.5) / 100), time
    ColourTell(
        "white", "black", name.." ", 
        "gray", "black", "has sent you medina map data ", 
        "white", "black", "[",
        "yellow", "black", percent.."\%",
        "white", "black", "]"
        )
    if t == "" then
        t = false
        Note("")
    else
        t = os.time() - tostring(t)
        ColourNote("gray", "black", " ("..string.format("%.2d:%.2d:%.2d", t/(60*60), t/60%60, t%60)..")")
    end
    ColourTell(
        "gray", "black", "Type/Click on ",
        "white", "black", "'"
    )
    Hyperlink ("medina sync", "medina sync", "Update medina map!", "yellow", "black", 0)
    ColourNote(
        "white", "black", "'",
        "gray", "black", " to update",
        "gray", "black", "!"
    )
    ColourNote(
        "gray", "black", "(This will override your current map.)"
    )
   if GetPluginInfo(GetPluginID (), 19) < tonumber(version) then
        ColourNote(
            "white", "black", "<",
            "red","black","There is a newer version of this plugin available!",
            "white", "black", ">")
    end
    return tbl, time
end

function apply_sync(tbl, time)
    load_med_rooms() -- reset
    for room, v in pairs(tbl) do
        for static, temp in pairs(v) do
            if temp then
                med_rooms[room].normalized[static] = temp
                med_rooms[room].exits = med_rooms[room].exits or {}
                med_rooms[room].exits[temp] = {exits = false, room = false}
                for adj_room, dir in pairs(med_rooms[room].exit_rooms) do
                    if static == dir then
                        med_rooms[room].exits[temp].room = adj_room
                    end
                end
            end
        end
        local unlocked = time or false
        for _, v in pairs(med_rooms[room].normalized) do 
            if not(v) then
                unlocked = false
            end
        end
        med_rooms[room].unlocked = unlocked
        if unlocked then
            set_expiration_timer(med_rooms, room)
        end
        med_rooms[room].mobs = false
    end
    print_medina()
end

function boss_to_group()
    local function simplify_path(t1)
        if type(t1) == "table" then
            local t2, count, last = {}, 0, ""
            for _, v in ipairs(t1) do
               if v == last then
                   t2[count].num = t2[count].num + 1
                else
                    count = count +1
                    t2[count] = {}
                    t2[count].txt = v
                    t2[count].num = 1
                    last = v
                end
            end
            return t2 
        else
            return false
        end
    end
    local function format_path(tbl)
        local path, comma = "group say boss is ", false --keeping format casual
        if type(tbl) == "table" then
            for i, v in ipairs(tbl) do
                if not(comma) then
                    if v.num > 1 then
                        path = path..v.num.." "..v.txt 
                    else
                        path = path..v.txt 
                    end
                else
                    if v.num > 1 then
                        path = path..", "..v.num.." "..v.txt 
                    else
                        path = path..", "..v.txt
                    end
                end
                comma = true
            end
            return path
        else
            return false
        end
    end
    local boss_room, start_room, to_group = false, room_sequence[1], ""
    for k, v in pairs(med_rooms) do
        if v.mobs then
            if v.mobs["Triad boss"] then
                boss_room = k
                break
            end
        end
    end
    if boss_room then
        if start_room ~= boss_room then
            if start_room then
                to_group = format_path(simplify_path(get_shortest_path(med_rooms, start_room, boss_room, true)))
                if to_group then
                    Note(to_group)
                end
            else
                to_group = format_path(simplify_path(get_shortest_path(med_rooms, "I", boss_room, true)))
                if boss_room == "I" then
                    Send("group say boss is in heart")
                else
                    if to_group then
                        Note(to_group.." from heart")
                    end
                end
            end
        end
    else
        ColourNote("white", "black", "<", "red", "black", "Boss location unknown!", "white", "black", ">")
    end
end
--------------------------------------------------------------------------------
--   PRINT MAP
--------------------------------------------------------------------------------
function get_map_measurments(win_w, win_h)
    mw_buffer_x = win_w * .05
    mw_buffer_y = win_h * .05
    map_width = win_w - mw_buffer_x*2
    map_height = win_h - mw_buffer_y*2
    block_x = map_width/6
    block_y = map_height/6
    room_width = block_x*.5
    room_height = block_y*.5
    exit_width = (block_x - room_width)/2
    exit_height = (block_y - room_height)/2 
    return mw_buffer_x, mw_buffer_y, map_width, map_height, block_x, block_y, room_width, room_height, exit_width, exit_height
end

function print_medina(in_room, look_room)
    local start_time = os.clock()
    WindowCircleOp (win, miniwin.circle_rectangle, -- mw border
                0, 0, WIN_WIDTH, WIN_HEIGHT,
                ColourNameToRGB("white"), miniwin.pen_solid, 1,
                ColourNameToRGB("black"), 0)-- brush

    WindowLine (win, 0, block_y/2, (mw_buffer_x), (mw_buffer_y)+block_y/2, ColourNameToRGB ("white"), miniwin.pen_dot, 1)
    WindowLine (win, (block_x*6)+mw_buffer_x, (block_y*5.5)+mw_buffer_y, (WIN_WIDTH), WIN_HEIGHT-(block_y/2), ColourNameToRGB ("white"), miniwin.pen_dot, 1)
    
    mob_text = {}
	local uncertainty = false
	if in_room == nil then in_room = false end
    if room_sequence[1] then in_room = room_sequence[1] end
	if look_room == "H or N" then look_room = "H"; uncertainty = "N" end
	
    EnableTrigger("exit_medina", true) -- miniwindow will exit after scrying remotly
    
    exit_set = {}
    local exit_sequence, exit_direction = {}, false
	if (look_room or (in_room and move_dir)) and room_sequence[1] then
		table.insert(exit_sequence, room_sequence[1])
		if look_room then
            if med_rooms[room_sequence[1]].exits then
                for k, v in pairs(med_rooms[room_sequence[1]].exits) do
                    if v.room == look_room then
                        exit_direction = k
                        break
                    end
                end
            end
		else 
			exit_direction = move_dir
		end
		if exit_direction then
			for i, v in ipairs(exit_sequence) do
				if med_rooms[exit_sequence[#exit_sequence]].exits then
					if med_rooms[exit_sequence[#exit_sequence]].exits[exit_direction] then
						if med_rooms[exit_sequence[#exit_sequence]].exits[exit_direction].room then
							if exit_set[med_rooms[exit_sequence[#exit_sequence]].exits[exit_direction].room] then
								break
							else
								exit_set[med_rooms[exit_sequence[#exit_sequence]].exits[exit_direction].room] = true
								table.insert(exit_sequence, med_rooms[exit_sequence[#exit_sequence]].exits[exit_direction].room)
							end
						else
							break
						end
					else
						break
					end
				else
					break
				end
			end
		end
		exit_set[room_sequence[1]] = true
    end
	
	local function get_exit_colour(room, dir, norm)
		local exit_colour = "red"
		if norm then exit_colour = "gray" end
		if med_rooms[room].exits and exit_set[room] and exit_direction then --med_rooms[room].exit_rooms[med_rooms[room].exits[exit_direction].room]
			if med_rooms[room].exits[exit_direction] then
				if med_rooms[room].exits[exit_direction].room then
					if med_rooms[room].exit_rooms[med_rooms[room].exits[exit_direction].room] then
						if dir == med_rooms[room].exit_rooms[med_rooms[room].exits[exit_direction].room] then
							exit_colour = "blue" --herding path
						end
					end
				end
			end
		end
		return(exit_colour)
	end
	
    local function give_direction(exit)
        if exit == "n" then return 0, 1 end
        if exit == "ne" then return 1, 1 end
        if exit == "e" then return 1, 0 end
        if exit == "se" then return 1, -1 end
        if exit == "s" then return 0, -1 end
        if exit == "sw" then return -1, -1 end
        if exit == "w" then return -1, 0 end
        if exit == "nw" then return -1, 1 end
    end

	local function get_room_colours(room, v)
        local function get_mob_colour(room, v)
            local count, boss_room, player_room, colour = 0, false, false, "darkgray"
            for k, n in pairs(v.mobs) do
                if n.type == "player" then
                    player_room = true
                    break
                elseif k == "Triad boss" then
                    boss_room = true
                elseif k == "Triad thug" then
                    count = count + n.quantity
                elseif k == "Triad heavy" then
                    count = count + n.quantity * 2
                elseif k == "Triad boss" then
                    boss_room = true
                end
            end
            if player_room then
                colour = "blue"
            elseif boss_room then
                colour = "fuchsia"
            elseif count > 8 then
                colour = "#00ff00"
            elseif count > 7 then
                colour = "#00e500"
            elseif count > 6 then
                colour = "#00cc00"
            elseif count > 5 then
                colour = "#00b200"
            elseif count > 4 then
                colour = "#009900"
            elseif count > 3 then
                colour = "#007f00"
            elseif count > 2 then
                colour = "#006600"
            elseif count > 1 then
                colour = "#004c00"
            elseif count > 0 then
                colour = "#003300"              
            end
            get_mob_text(room, v, colour)
            return colour
        end
		local border_colour, inner_colour = "red", "black"
        if room == room_sequence[#room_sequence] then 
            border_colour = "yellow"
		elseif exit_set[room] and (room ~= room_sequence[1]) then 
			border_colour = "blue"
		elseif v.unlocked then
			border_colour = "gray"
        end
        if room == room_sequence[1] then 
			inner_colour = "yellow"
            if v.mobs then
                get_mob_colour(room, v)
            end
        elseif room == (look_room or uncertainty) then 
			inner_colour = "white"
            if v.mobs then
                border_colour = get_mob_colour(room, v)
            end
        elseif v.mobs then
            inner_colour = get_mob_colour(room, v)
        end
		return border_colour, inner_colour
	end

    local function draw_room(x_pos, y_pos, room, room_value)
        
        local border_colour, inner_colour = get_room_colours(room, room_value)

        local room_center_x = mw_buffer_x + (x_pos*block_x) - (block_x/2)
        local room_center_y = mw_buffer_y + (y_pos*block_y)

        local x1 = room_center_x - (room_width/2)
	    local y1 = room_center_y - (room_height/2)
	    local x2 = room_center_x + (room_width/2)
        local y2 = room_center_y + (room_height/2)

	    WindowCircleOp (win, 2, -- room
	    x1, y1, x2, y2,                 -- Left, Top, Right, Bottom
	    ColourNameToRGB(border_colour), 0, 1, -- pen width 
	    ColourNameToRGB("black"), 0)  -- brush    
        local width = WindowTextWidth (win, "f", room)  -- width of text
        
        x1 = room_center_x - (room_width*.75/2)
	    y1 = room_center_y - (room_height*.75/2)
	    x2 = room_center_x + (room_width*.75/2)
        y2 = room_center_y + (room_height*.75/2)

	    WindowCircleOp (win, 2, -- inner square
	    x1, y1, x2, y2,                 -- Left, Top, Right, Bottom
	    ColourNameToRGB(inner_colour), 0, 1, -- pen width 
	    ColourNameToRGB(inner_colour), 0)  -- brush    

        local width, room_text_color = WindowTextWidth (win, "f", room), ColourNameToRGB("lightblue")
        if room_value.visited then
            room_text_color =ColourNameToRGB("gray")
        end
        x1 = room_center_x - (room_width/2) + (room_width-width)/2
        y1 = room_center_y - (room_height/2)
        WindowText (win, "f", room,
        x1, y1, 0, 0, -- rectangle
        room_text_color, 
        false) -- not Unicode
     end

    local function draw_exit(x_pos, y_pos, exit_dir, norm, exit_colour)
        x_dir, y_dir = give_direction(exit_dir) 
        local exit_center_x = mw_buffer_x + (x_pos*block_x) - (block_x/2) + ((room_width + exit_width)/2)*x_dir
        local exit_center_y = mw_buffer_y + (y_pos*block_y) + ((room_height + exit_height)/2)*-y_dir 
        
        local x1 = exit_center_x - exit_width/2
        local y1 = exit_center_y - exit_height/2
        local x2 = exit_center_x + exit_width/2
        local y2 = exit_center_y + exit_height/2
        
        if norm then WindowDrawImage(win, norm, x1+2, y1+2, 0, 0, 1) end

        WindowCircleOp (win, 2, -- square
	    x1, y1, x2, y2,                 -- Left, Top, Right, Bottom
	    ColourNameToRGB(exit_colour), 0, 1, -- pen width 
	    ColourNameToRGB("black"), miniwin.brush_null)  -- brush     
    end

    local function write_exit_text(styles, plain, unlocked) 
        local dir = {n = true, ne = true, e = true, se = true, s = true, sw = true, w = true, nw = true}
        for k, v in pairs(dir) do
            WindowDeleteHotspot(win, k)
        end
        if unlocked == true then
            plain = "[room solved]"
            styles = {}
                --{colour = "white", text = "["},
                --{colour = "gray", text = "room solved"},
                --{colour = "white", text = "]"}}
        end
        local width = WindowTextWidth (win, "f", plain)  -- width of text
        local left = (WIN_WIDTH - width)/2
        local top =  mw_buffer_y + block_y*5.5
        for _, v in ipairs (styles) do
            if dir[v.text] then
                 WindowAddHotspot(win, v.text,  
                    left, top, left+WindowTextWidth (win, "f", v.text), top+font_height,
                    "mouseover", 
                    "cancelmouseover", 
                    "mousedown",
                    "cancelmousedown", 
                    "mouseup", 
                    "Look "..v.text,  -- tooltip text
                    miniwin.cursor_hand, 0)  -- hand cursor  
            end
            left = left + WindowText (win, "f", v.text, left, top, left+WindowTextWidth (win, "f", v.text), top+font_height, ColourNameToRGB(v.colour))
        end
    end

    local function write_title_text(room) 
        local title, colour = "", "gray"
        local styles = {
            {text = "dw", colour = colour},
            {text = "cwc", colour = colour},
            {text = "bp", colour = colour},
            {text = "rt", colour = colour},
            {text = "medina", colour = "red"}
        }
        if room then table.insert(styles, {text = room, colour = colour}) end
        for i = 2, (#styles-1)*2, 2 do
            table.insert(styles, i, {text = "/", colour = "gray"})
        end
        table.insert(styles, 1, {text = "[", colour = "white"});table.insert(styles, {text = "]", colour = "white"})
        for _, v in ipairs(styles) do
            title = title..v.text
        end
        local width = WindowTextWidth (win, "f", title)
        local left = (WIN_WIDTH - width)/2
        local top =  mw_buffer_y

        for _, v in ipairs (styles) do
            left = left + WindowText (win, "f", v.text, left, top, WIN_WIDTH, WIN_HEIGHT, ColourNameToRGB(v.colour))
        end
    end

	for room, v in pairs(med_rooms) do
        for dir, norm in pairs(v.normalized) do
            draw_exit(v.mw_location.x, v.mw_location.y, dir, norm, get_exit_colour(room, dir, norm))
		end
        draw_room(v.mw_location.x, v.mw_location.y, room, v)
	end
	if in_room then
		if med_rooms[in_room].exits then -- write exits
            local locked_exits = {}
			for k, v in order_exits(med_rooms[in_room].exits) do
                if not(in_room == "A" and k == "nw") and not(in_room == "R" and k == "se") and not(v.room) then
                    table.insert(locked_exits, k)
                end
			end
            local exit_text, plain_text, comma = {}, "[", false
            for _, v in ipairs(locked_exits) do
                if comma then
                    table.insert(exit_text, {colour = "white", text = ", "})
                    plain_text = plain_text..", "
                else
                    table.insert(exit_text, {colour = "white", text = "["})
                end
                table.insert(exit_text, {colour = "red", text = v})
                plain_text = plain_text..v
                comma = true
            end
            plain_text = plain_text.."]"
            table.insert(exit_text, {colour = "white", text = "]"})
            local unlocked = false; if #locked_exits == 0 then unlocked = true end
            write_exit_text(exit_text, plain_text, unlocked)
		end
	end
    write_title_text(in_room) 
    WindowShow(win)
    --print(os.clock() - start_time) --speed test
end
--------------------------------------------------------------------------------
--   MOB/BOSS TRACKING
--------------------------------------------------------------------------------
function get_mobs(mobs, room, is_look, direction)
    local function word_to_int(text) -- replace written words with integers
        local function first_to_upper(str)
            return (str:gsub("^%l", string.upper))
        end
        local numbers = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty", "many"} --need to figure out what to do on many
        text = text:gsub("^[Aa]n? ","one "):gsub(", [Aa]n? ",", one "):gsub("^The ","one "):gsub(", the ",", one ")
        for i, word in ipairs(numbers) do
            text = text:gsub(", "..word.." ", ", "..i.." "):gsub("^"..word.." ", i.." "):gsub(", "..first_to_upper(word).." ", ", "..i.." "):gsub("^"..first_to_upper(word).." ", i.." ")
        end
        return text
    end
    local function parse_mobs(str)
        local function combine(t1)
            local t2 = {}
            for i, v in ipairs(t1) do
                for num, item in string.gmatch(v, "(%d+)%s(.+)") do
                    if t2[item] then
                        t2[item] = t2[item] + tonumber(num)
                    else
                        t2[item] = tonumber(num)
                    end
                end
            end
            return t2
        end
        local tbl = {}
        for w in str:gmatch("(.-), ") do 
                if w:match("^%D") then
                    table.insert(tbl, ("1 "..w))
                elseif w:match("^1 ") then
                    table.insert(tbl,  w)
                else
                    table.insert(tbl, (w:gsub("ies$","y"):gsub("s$","")))
                end
        end
        return combine(tbl)
    end
    local function table_length(t)
        local count = 0
        for _ in pairs(t) do count = count + 1 end
        return count
    end
    local function mob_type(str)
        local type = ""
        if str == "Triad boss" or str == "Triad heavy" or str == "Triad thug" then
            type = "xp"
        elseif str == "Ryattenoki" or str == "Very Reverend Khepresh" or str == "Triad undertaker" or str:match(".* cloud$") or str:match(".* fruitbat.*") or str:match(".* truffle pig$") then
            type = "npc"
        else
            type = "player"
        end
        return type
    end
    local function update_mobs(room)
        if mobs:match(".* %w+ %w+ing here[.]$") or mobs:match(".* %w+ %w+ing in the air here[.]$") then
            mobs = word_to_int(mobs:gsub("ing in the air here","ing here"):gsub(" %w+ %w+ing here[.]$",", "):gsub(" %w+ %w+ing here and ", ", "):gsub(" %w+ %w+ing here[,] ", ", "):gsub(" and ", ", "))
            med_rooms[room].mobs = {}
            for k, v in pairs(parse_mobs(mobs)) do
                med_rooms[room].mobs[k] = {quantity = v, type = mob_type(k)} --set mobs
                if ((k == "Triad boss") or (med_rooms[room].mobs[k].type ~= "xp")) and not(uncertainty) then
                    for kk, vv in pairs(med_rooms) do
                        if vv.mobs and (kk ~= room) then
                            if vv.mobs[k] then
                                med_rooms[kk].mobs[k] = nil --remove duplicate unique npc/players unless uncertainty
                                if table_length(med_rooms[kk].mobs) == 0 then
                                    med_rooms[kk].mobs = false
                                end
                            end
                        end
                    end
                end
            end
        elseif mobs:match(".* stumbles? in from one of the alleys[.]$") or mobs:match(".* arrivess? from the %w+[.]$") or mobs:match(".* emerges? from a thaumic door which appears in midair[.]$") or mobs:match(".* follows? .* in[.]$") then 
            mobs = word_to_int(mobs:gsub(" stumbles? in from one of the alleys[.]$",", "):gsub(" arrives? from the %w+[.]$",", "):gsub(" emerges? from a thaumic door which appears in midair[.]$",", "):gsub(" follows? .* in[.]$",", "):gsub(" and ", ", "))
            if not(med_rooms[room].mobs) then med_rooms[room].mobs  = {} end
            for k, v in pairs(parse_mobs(mobs)) do
                if med_rooms[room].mobs[k] then
                    if med_rooms[room].mobs[k].type == "xp" then
                        med_rooms[room].mobs[k].quantity = med_rooms[room].mobs[k].quantity + v --add mobs
                    else
                        med_rooms[room].mobs[k].quantity = 1
                    end
                else
                    med_rooms[room].mobs[k] = {quantity = v, type = mob_type(k)}
                end
                if ((k == "Triad boss") or (med_rooms[room].mobs[k].type ~= "xp")) and not(uncertainty) then
                    for kk, vv in pairs(med_rooms) do
                        if vv.mobs and (kk ~= room) then
                            if vv.mobs[k] then
                                med_rooms[kk].mobs[k] = nil --remove duplicate unique npc/players unless uncertainty
                                if table_length(med_rooms[kk].mobs) == 0 then
                                    med_rooms[kk].mobs = false
                                end
                            end
                        end
                    end
                end
            end
        elseif mobs:match(".* leaves? %w+[.]$") or mobs:match(".* stumbles? off to the %w+[.]$") or mobs:match(".* moves? through the .*$") or mobs:match(".* follows? .* out[.]$") then
            mobs = word_to_int(mobs:gsub(" leaves? %w+[.]$",", "):gsub(" stumbles? off to the %w+[.]$",", "):gsub(" moves? through the .*$",", "):gsub(" follows? .* out[.]$",", "):gsub(" and ", ", "))
            if not(med_rooms[room].mobs) then med_rooms[room].mobs = {} end
            for k, v in pairs(parse_mobs(mobs)) do
                if med_rooms[room].mobs[k] then
                    if k ~= "Triad thug" and k ~= "Triad heavy" then
                        if med_rooms[room].exits then
                            if med_rooms[room].exits[direction] then
                                if med_rooms[room].exits[direction].room then
                                    if med_rooms[med_rooms[room].exits[direction].room] then
                                        med_rooms[med_rooms[room].exits[direction].room].mobs = med_rooms[med_rooms[room].exits[direction].room].mobs or {}
                                        med_rooms[med_rooms[room].exits[direction].room].mobs[k] = {quantity = 1, type = med_rooms[room].mobs[k].type}
                                    end
                                end
                            end
                        end
                    end
                    med_rooms[room].mobs[k].quantity = med_rooms[room].mobs[k].quantity - v --subtract mobs
                    if med_rooms[room].mobs[k].quantity <= 0 then
                        med_rooms[room].mobs[k] = nil
                    end
                end
            end
            if table_length(med_rooms[room].mobs) == 0 then
                med_rooms[room].mobs = false
            end
        elseif mobs:match(".* succeeds? in following you[.]$") then
            mobs = word_to_int(mobs:gsub(" succeeds? in following you[.]$",", "):gsub(" and ", ", "))
            if previous_room then
                if med_rooms[previous_room].mobs then 
                    for k, v in pairs(parse_mobs(mobs)) do
                        if med_rooms[previous_room].mobs[k] then
                            med_rooms[previous_room].mobs[k].quantity = med_rooms[previous_room].mobs[k].quantity - v --subtract mobs from previous room
                            if med_rooms[previous_room].mobs[k].quantity <= 0 then
                                med_rooms[previous_room].mobs[k] = nil
                            end
                        end
                    end
                    if table_length(med_rooms[previous_room].mobs) == 0 then
                        med_rooms[previous_room].mobs = false
                    end
                end
            end
        elseif mobs:match("^You kill .*$") or mobs:match("^.* deals the death blow to .*$") then
            mobs = mobs:gsub("^You kill ",""):gsub("^.* deals the death blow to ",""):gsub("[.]$",""):gsub("^[Tt]he ","")
            if med_rooms[room].mobs then
                if med_rooms[room].mobs[mobs] then
                    med_rooms[room].mobs[mobs].quantity = med_rooms[room].mobs[mobs].quantity - 1
                    if med_rooms[room].mobs[mobs].quantity <= 0 then 
                        med_rooms[room].mobs[mobs] = nil
                    end
                end
                if table_length(med_rooms[room].mobs) == 0 then
                    med_rooms[room].mobs = false
                end
            end
        else
            med_rooms[room].mobs = false
        end
    end
    local uncertainty = false
    if room == "H or N" then room = "H"; uncertainty = "N" end
    if is_look then
        med_rooms[room].mobs = false --clear mobs
    end
    update_mobs(room)
    if uncertainty then update_mobs(uncertainty) end
    if room_sequence[1] and room and is_look then
        if room_sequence[1] ~= room then
            print_medina(room_sequence[1], room)
        else
            print_medina(room) 
        end
    else
        print_medina(room)
    end
end
function follow_delay(name)
    local function table_length(T)
        local count = 0
        for _ in pairs(T) do count = count + 1 end
        return count
    end
    local previous_room = name:match("^[A-R]")
    local current_room = name:match("^[A-R]([A-R])")
    local is_boss = false
    if name:match("^[A-R][A-R]true$") then
        is_boss = true
    end
    if med_rooms[previous_room].mobs then
        local is_p_room = false
        for k, v in pairs(med_rooms[previous_room].mobs) do
            if v.type == "player" then
                is_p_room = true -- mobs will not follow if players still in previous room
                break
            end
        end
        if not(is_p_room) then
            if not(med_rooms[current_room].mobs) then med_rooms[current_room].mobs = {} end
            if med_rooms[previous_room].mobs["Triad thug"] then
                if med_rooms[current_room].mobs["Triad thug"] then
                    if current_room ~= room_sequence[1] then
                        med_rooms[current_room].mobs["Triad thug"].quantity = med_rooms[current_room].mobs["Triad thug"].quantity + med_rooms[previous_room].mobs["Triad thug"].quantity
                    end
                    med_rooms[previous_room].mobs["Triad thug"] = nil
                else
                    if current_room ~= room_sequence[1] then
                        med_rooms[current_room].mobs["Triad thug"] = {quantity = med_rooms[previous_room].mobs["Triad thug"].quantity, type = med_rooms[previous_room].mobs["Triad thug"].type}
                    end
                    med_rooms[previous_room].mobs["Triad thug"] = nil
                end
            end
            if med_rooms[previous_room].mobs["Triad heavy"] then
                if med_rooms[current_room].mobs["Triad heavy"] then
                    if current_room ~= room_sequence[1] then
                        med_rooms[current_room].mobs["Triad heavy"].quantity = med_rooms[current_room].mobs["Triad heavy"].quantity + med_rooms[previous_room].mobs["Triad heavy"].quantity
                    end
                    med_rooms[previous_room].mobs["Triad heavy"] = nil
                else
                    if current_room ~= room_sequence[1] then
                        med_rooms[current_room].mobs["Triad heavy"] = {quantity = med_rooms[previous_room].mobs["Triad heavy"].quantity, type = med_rooms[previous_room].mobs["Triad heavy"].type}
                    end
                    med_rooms[previous_room].mobs["Triad heavy"] = nil
                end
            end
            if is_boss then
                if current_room ~= room_sequence[1] then
                    for k, v in pairs(med_rooms) do
                        if v.mobs then
                            if med_rooms[k].mobs["Triad boss"] then
                                med_rooms[k].mobs["Triad boss"] = nil
                            end
                            if table_length(v.mobs) == 0 then
                                med_rooms[k].mobs = false
                            end
                        end
                    end
                    med_rooms[current_room].mobs = med_rooms[current_room].mobs or {}
                    med_rooms[current_room].mobs["Triad boss"] = {quantity = 1, type = "xp"}
                end
            end
            if type(med_rooms[previous_room].mobs) == "table" then
                if table_length(med_rooms[previous_room].mobs) == 0 then
                    med_rooms[previous_room].mobs = false
                end
            end
        end
    end
    if WindowInfo (win, 5) then
        print_medina()--this is the reason
    end
end
function mob_follow(current_room, previous_room)
    for i = 1, med_rooms[previous_room].mobs["Triad thug"].quantity , 1 do
        if med_rooms[current_room].exits then
            if med_rooms[current_room].exits[move_dir] then
                if med_rooms[current_room].exits[move_dir].room then
                    current_room = med_rooms[current_room].exits[move_dir].room -- mob tracking
                end
            end
        end
    end
    local is_boss = ""
    if med_rooms[previous_room].mobs["Triad boss"] then is_boss = "true" end
    if current_room and previous_room then
        AddTimer(previous_room..current_room..is_boss, 0, 0, 5.25, "", timer_flag.Enabled + timer_flag.Replace + timer_flag.Temporary + timer_flag.OneShot, "follow_delay")
    end
end
function get_mob_text(room, value, colour)
    local function pluralize(str)
        if str == "Triad heavy" then
            str = str:gsub("y$", "ies")
        else
            str = str:gsub("$", "s")
        end
        return str
    end
    local function get_name_colour(name, type)
        local col = "gray"
        if name == "Triad boss" then
            col = "fuchsia"
        elseif name == "Triad heavy" then
            col = "yellow"
        elseif name == "Triad thug" then
            col = "white"
        elseif type == "player" then
            col = "blue"
        end
        return col
    end
    
    local count, style_line, is_first, bracket_col, mobs_exist = 0, {}, true, "white", false
    if room_sequence[1] then
        if room_sequence[1] == room then
            bracket_col, colour = "yellow", "yellow"
        end
    end
    table.insert(style_line, {col = bracket_col ,txt = "["})
    table.insert(style_line, {col = colour, txt = room})
    table.insert(style_line, {col = bracket_col ,txt = "] "})
    for k, v in pairs(value.mobs) do
        mobs_exist = true
        if not(is_first) then
            table.insert(style_line, {col = "gray" ,txt = ", "})
        end
        if v.quantity > 1 then 
            table.insert(style_line, {col = get_name_colour(k, v.type) ,txt = tostring(v.quantity).." "})
            table.insert(style_line, {col = get_name_colour(k, v.type) ,txt = string.lower(pluralize(k))})
        else
            table.insert(style_line, {col = get_name_colour(k, v.type) ,txt = string.lower(k)})
        end
        count = count + v.quantity
        is_first = false
    end
    table.insert(style_line, {col = "gray" ,txt = " ["..tostring(count).." thyng"})
    if count > 1 then
        table.insert(style_line, {col = "gray" ,txt = "s"})
    end
    table.insert(style_line, {col = "gray" ,txt = "]"})
    if mobs_exist then
        mob_text[room] = style_line
    end
end

function print_mob_text(this_room, is_only_print_this_room)
    --[[local room_list = {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R"}
    if is_only_print_this_room then
        if type(mob_text[this_room]) == "table" then
            for i, v in ipairs(mob_text[this_room]) do
                ColourTell(v.col, "black", v.txt)
            end
            Note()
        end
    else
        for _, rm in ipairs(room_list) do
            if (type(mob_text[rm]) == "table") and (rm ~= this_room) then
                for i, v in ipairs(mob_text[rm]) do
                    ColourTell(v.col, "black", v.txt)
                end
                Note()
            end
        end
    end]]
end
--------------------------------------------------------------------------------
--   UNLOCKING EXITS
--------------------------------------------------------------------------------
function log_exits(room, exits)
	local temp_exits = {}
	if exits:match(" north[%s%.,]") then table.insert(temp_exits, "n") end
	if exits:match(" northeast[%s%.,]") then table.insert(temp_exits, "ne") end
	if exits:match(" east[%s%.,]") then table.insert(temp_exits, "e") end
	if exits:match(" southeast[%s%.,]") then table.insert(temp_exits, "se") end
	if exits:match(" south[%s%.,]") then table.insert(temp_exits, "s") end
	if exits:match(" southwest[%s%.,]") then table.insert(temp_exits, "sw") end
	if exits:match(" west[%s%.,]") then table.insert(temp_exits, "w") end
	if exits:match(" northwest[%s%.,]") then table.insert(temp_exits, "nw") end
	if not(med_rooms[room].exits) then
		med_rooms[room].exits = {}
		for i, v in ipairs(temp_exits) do
			med_rooms[room].exits[v] = {room = false, exits = false}
		end

	else -- check if exits have changed
		local exit_change = false
		for i, v in ipairs(temp_exits) do
			if not(med_rooms[room].exits[v]) then
				exit_change = true
				break
			end
		end
		if exit_change then -- reset if they have
			reset_room(room)
			med_rooms[room].exits = {}
			for i, v in ipairs(temp_exits) do
				med_rooms[room].exits[v] = {room = false, exits = false}
			end
		end
	end
end

function log_look_exits(room, exits)
	if look_dir[1] then
        if room_sequence[1] then
            if med_rooms[room_sequence[1]].exits then
                if med_rooms[room_sequence[1]].exits[look_dir[1]] ~= nil then
                        med_rooms[room_sequence[1]].exits[look_dir[1]].exits = {}
                        if exits:match(" north[%s%.,]") then med_rooms[room_sequence[1]].exits[look_dir[1]].exits.n = true end
                        if exits:match(" northeast[%s%.,]") then med_rooms[room_sequence[1]].exits[look_dir[1]].exits.ne = true end
                        if exits:match(" east[%s%.,]") then med_rooms[room_sequence[1]].exits[look_dir[1]].exits.e = true end
                        if exits:match(" southeast[%s%.,]") then med_rooms[room_sequence[1]].exits[look_dir[1]].exits.se = true end
                        if exits:match(" south[%s%.,]") then med_rooms[room_sequence[1]].exits[look_dir[1]].exits.s = true end
                        if exits:match(" southwest[%s%.,]") then med_rooms[room_sequence[1]].exits[look_dir[1]].exits.sw = true end
                        if exits:match(" west[%s%.,]") then med_rooms[room_sequence[1]].exits[look_dir[1]].exits.w = true end
                        if exits:match(" northwest[%s%.,]") then med_rooms[room_sequence[1]].exits[look_dir[1]].exits.nw = true end
                end
            end
        end
	end
	log_exits(room, exits)
end

function move_room(room)
    med_rooms[room].visited = true
    if room_sequence[1] ~= nil then --can be T/F but not nil
        previous_room = room_sequence[1]
        local current_room = room_sequence[1]
		if q_command[1] == "l" then
			table.remove(q_command, 1)
			table.remove(room_sequence, 1)
			room_sequence[1] = room	
			move_dir = false
		else
			if room_sequence[2] then 
				if room_sequence[2] ~= room then
					med_rooms[room_sequence[1]].normalized = {}
					for _, v in pairs(med_rooms[room_sequence[1]].exit_rooms) do
						if not(room_sequence[1] == "A" and v == "nw") and not(room_sequence[1] == "R" and v == "se") then
							med_rooms[room_sequence[1]].normalized[v] = false
						end
					end
					med_rooms[room_sequence[1]].unlocked = false
					for k, _ in pairs(med_rooms[room_sequence[1]].exits) do
						med_rooms[room_sequence[1]].exits[k] = {room = false, exits = false}
					end	
				end
			end
			if q_command[1] then
                if med_rooms[room_sequence[1]].exits then
                    med_rooms[room_sequence[1]].exits[q_command[1]].room = room
                    med_rooms[room_sequence[1]].normalized[med_rooms[room_sequence[1]].exit_rooms[room]] = q_command[1]
                    process_elimination(room_sequence[1])
                    move_dir = q_command[1]
                    table.remove(q_command, 1)
                else
                    move_dir = q_command[1]
                    table.remove(q_command, 1)
                end
			end
			table.remove(room_sequence, 1)
			room_sequence[1] = room
		end
        if med_rooms[previous_room].mobs and move_dir then
            if med_rooms[previous_room].mobs["Triad thug"] then
                mob_follow(current_room, previous_room) -- mob following
            end
        end
	elseif q_command[1] then
		move_dir = q_command[1]
		table.remove(q_command, 1)
		room_sequence[1] = room
	else
		move_dir = false
		room_sequence[1] = room
	end
end

function look_room(room)
     med_rooms[room].visited = true
    if room_sequence[1] then
        if med_rooms[room_sequence[1]].exits then
           med_rooms[room_sequence[1]].exits[look_dir[1]].room = room
           med_rooms[room_sequence[1]].normalized[med_rooms[room_sequence[1]].exit_rooms[room]] = look_dir[1]
           process_elimination(room_sequence[1])
        end
    end
	table.remove(look_dir, 1)
end

function process_elimination(room) -- this function will automaticly determine the last unlocked exit in a room via process of elimination
	local p, last_unlocked = 0, ""
    if med_rooms[room].exits then
        for k, v in pairs(med_rooms[room].exits) do
            if not(v.room) then
                if not(room == "R" and k == "se") and not(room == "A" and k == "nw") then
                    last_unlocked = k
                    p = p + 1
                end
                if p > 1 then break end
            end
        end
        if p == 1 then
            for k, v in pairs(med_rooms[room].exit_rooms) do
                if not(med_rooms[room].normalized[v]) then
                    med_rooms[room].normalized[v] = last_unlocked
                    med_rooms[room].exits[last_unlocked].room = k
                    med_rooms[room].unlocked = os.time()
                    set_expiration_timer(med_rooms, room)
                    break
                end
            end
        end
    end
end
--------------------------------------------------------------------------------
--   RESET FUNCTIONS
--------------------------------------------------------------------------------
function reset_room(room)
	med_rooms[room].normalized = {}
		for _, v in pairs(med_rooms[room].exit_rooms) do
			med_rooms[room].normalized[v] = false
		end
	med_rooms[room].unlocked = false
    DeleteTimer(room)
	med_rooms[room].exits = false
    med_rooms[room].mobs = false
    med_rooms[room].visited = false
	med_rooms.A.normalized.nw = "nw" -- these are the static exits to medina
	med_rooms.R.normalized.se = "se"
end

function set_expiration_timer(tbl, room)
    local time_limit = 14 * 60 * 60 -- seconds
    if tbl[room].unlocked then
        local time_since = time_limit - (os.time() - tbl[room].unlocked)
        if time_since < 1 then 
            expire_room(room)
        else
            local h, m, s = time_units(time_since)
            AddTimer(room, h, m, s, "", timer_flag.Enabled + timer_flag.Temporary + timer_flag.OneShot, "expire_room")
        end
    end
end

function expire_room(name)
    reset_room(name)
    local last_room = true
    for k, v in pairs(med_rooms) do --resets all partially unlocked when the last unlocked room expires
        if v.unlocked then
            last_room = false
            break
        end
    end
    if last_room then
        load_med_rooms()
    end
    if WindowInfo (win, 5) then
        print_medina()
    end
end

function clear_mobs()
    for k, v in pairs(med_rooms) do
        med_rooms[k].visited = false
        med_rooms[k].mobs = false
    end
end
--------------------------------------------------------------------------------
--   SHORTEST PATH
--------------------------------------------------------------------------------
function get_shortest_path(graph, start_node, end_node, is_for_text)
    local function deepcopy(orig)
        local orig_type = type(orig)
        local copy
        if orig_type == 'table' then
            copy = {}
            for orig_key, orig_value in next, orig, nil do
                copy[deepcopy(orig_key)] = deepcopy(orig_value)
            end
            setmetatable(copy, deepcopy(getmetatable(orig)))
        else -- number, string, boolean, etc
            copy = orig
        end
        return copy
    end
    local g, solved = deepcopy(graph), false
    if start_node then
        local queue, visited, current = {}, {}, ""
        queue[1] = start_node
        visited[start_node] = true
        g[start_node].parent = false
        while #queue > 0 do
            current = queue[1]
            table.remove(queue, 1)
           if current == end_node then
                solved = true
               break
            end
            for k, v in pairs(g[current].exit_rooms) do
                if not(visited[k]) then
                    if g[current].normalized[v] then
                        visited[k] = true
                        table.insert(queue, k)
                        g[k].parent = current
                    end
                end
            end  
        end
        local path, source_node = {}, g[end_node].parent
        while source_node do
            table.insert(path, 1, source_node)
            source_node = g[source_node].parent
        end
        table.insert(path, end_node);table.remove(path, 1)
        local path_text = {}
        if solved then
            current = start_node
            for _, v in ipairs(path) do
                if is_for_text then
                    table.insert(path_text, g[current].normalized[g[current].exit_rooms[v]])
                else
                    Execute(g[current].exit_rooms[v])
                end
                current = v
            end
            if is_for_text then return path_text end
        else
            ColourNote("white", "black", "<", "red", "black", "No path found. Unlock more exits!", "white", "black", ">")
        end
    end
    return solved
end
--------------------------------------------------------------------------------
--   MISC.
--------------------------------------------------------------------------------
function time_units(num)
    local function remainder(a, b)
        return a-math.floor(a/b)*b
    end
    local h, m, s = 0, 0, 0
    if num > 59 then
        s = remainder(num, 60)
        num = num/60
        if num > 59 then
            m = math.floor(remainder(num, 60))
            h = math.floor(num/60)
        else
            m = math.floor(num)
        end
    else
        s = num
    end
    return h, m, s
end

function order_exits(t)
local T = {}
for k, v in pairs(t) do
   table.insert(T, k)
end
local order = {n = 1, ne = 2, e = 3, se = 4, s = 5, sw = 6, w = 7, nw = 8}
table.sort(T, function(a,b) return order[a]<order[b] end)
local i = 0
    return function()
        i = i + 1
        if T[i] then
            return T[i], t[T[i]]
        end
    end
end

function format_time(start_time)
	if start_time then
		local end_time = os.time()
		minutes = math.floor((end_time-start_time)/60)
		seconds = (end_time-start_time)-(minutes*60)
		if seconds < 10 then
			seconds = "0"..tostring(seconds)
		end
		if minutes < 10 then
			return(tostring("  "..minutes..":"..seconds))
		elseif minutes < 100 then
			return(tostring(" "..minutes..":"..seconds))
		else
			return(tostring(minutes..":"..seconds))
		end
	
	else
		return ""
	end
end
--------------------------------------------------------------------------------
--   LOAD META-TABLE
--------------------------------------------------------------------------------
function load_med_rooms()
	med_rooms = {
	A = {exit_rooms = {B = "e", E = "se", D = "s"}, mw_location = {x = 1, y = 1}}, -- nw exit room
	B = {exit_rooms = {C = "e", E = "s", A = "w"}, mw_location = {x = 2, y = 1}},
	C = {exit_rooms = {F = "s", B = "w"}, mw_location = {x = 3, y = 1}},
	D = {exit_rooms = {A = "n", E = "e", H = "se"}, mw_location = {x = 1, y = 2}},
	E = {exit_rooms = {B = "n", F = "e", I = "se", D = "w", A = "nw"}, mw_location = {x = 2, y = 2}}, -- five-exit room
	F = {exit_rooms = {C = "n", G = "e", I = "s", E = "w"}, mw_location = {x = 3, y = 2}},
	G = {exit_rooms = {K = "se", F = "w"}, mw_location = {x = 4, y = 2}},
	H = {exit_rooms = {I = "e", L = "se", D = "nw", }, mw_location = {x = 2, y = 3}},
	I = {exit_rooms = {F = "n", J = "e", M = "se", L = "s", H = "w", E = "nw"}, mw_location = {x = 3, y = 3}}, -- heart
	J = {exit_rooms = {K = "e", N = "se", I = "w"}, mw_location = {x = 4, y = 3}},
	K = {exit_rooms = {J = "w", G = "nw"}, mw_location = {x = 5, y = 3}},
	L = {exit_rooms = {I = "n", M = "e", O = "s", H = "nw"}, mw_location = {x = 3, y = 4}},
	M = {exit_rooms = {N = "e", P = "s", L = "w", I = "nw"}, mw_location = {x = 4, y = 4}},
	N = {exit_rooms = {Q = "s", M = "w", J = "nw"}, mw_location = {x = 5, y = 4}},
	O = {exit_rooms = {L = "n", P = "e"}, mw_location = {x = 3, y = 5}},
	P = {exit_rooms = {M = "n", Q = "e", O = "w"}, mw_location = {x = 4, y = 5}},
	Q = {exit_rooms = {N = "n", R = "e", P = "w"}, mw_location = {x = 5, y = 5}},
	R = {exit_rooms = {Q = "w"}, mw_location = {x = 6, y = 5}} -- se exit room
	}
	for room, _ in pairs(med_rooms) do
		for _2, v in pairs(med_rooms[room].exit_rooms) do
			med_rooms[room].normalized = med_rooms[room].normalized or {}
			med_rooms[room].normalized[v] = false
		end
		med_rooms[room].unlocked = false
		med_rooms[room].exits = false
        med_rooms[room].mobs = false
        med_rooms[room].visited = false 
	end
	med_rooms.A.normalized.nw = "nw"
	med_rooms.R.normalized.se = "se"
end
--------------------------------------------------------------------------------
--   HOTSPOT HANDLERS
--------------------------------------------------------------------------------
function create_hotspots(med_rooms)
    for k, v in pairs(med_rooms) do

        local room_center_x = mw_buffer_x + (v.mw_location.x*block_x) - (block_x/2)
        local room_center_y = mw_buffer_y + (v.mw_location.y*block_y)

        local x1 = room_center_x - (room_width/2)
	    local y1 = room_center_y - (room_height/2)
	    local x2 = room_center_x + (room_width/2)
        local y2 = room_center_y + (room_height/2)

        WindowAddHotspot(win, k,  
            x1, y1, x2, y2,                 -- Left, Top, Right, Bottom
            "mouseover", 
            "cancelmouseover", 
            "mousedown",
            "cancelmousedown", 
            "mouseup", 
            "Room "..k,  -- tooltip text
            miniwin.cursor_hand, 0)  -- hand cursor   
     end
    WindowAddHotspot(win, "exit_nw",  
        0, 0, mw_buffer_x + (block_x) - (block_x/2) - (room_width/2), mw_buffer_y + (block_y) - (room_height/2),
        "mouseover", 
        "cancelmouseover", 
        "mousedown",
        "cancelmousedown", 
        "mouseup", 
        "Exit nw",  -- tooltip text
        miniwin.cursor_hand, 0)  -- hand cursor  
    WindowAddHotspot(win, "exit_se",
        (mw_buffer_x + (6*block_x) - (block_x/2)) + (room_width/2), mw_buffer_y + (5*block_y) + (room_height/2), WIN_WIDTH, WIN_HEIGHT,
        "mouseover", 
        "cancelmouseover", 
        "mousedown",
        "cancelmousedown", 
        "mouseup", 
        "Exit se",  -- tooltip text
        miniwin.cursor_hand, 0)  -- hand cursor  
end
function dragmove(flags, hotspot_id)
	if hotspot_id == "z_body" then
		local posx, posy = WindowInfo (win, 17), WindowInfo (win, 18)
		-- move the window to the new location
		WindowPosition(win, posx - startx, posy - starty, 0, 2)
  
		-- change the mouse cursor shape appropriately
		if posx < 0 or posx > GetInfo (281) or
		posy < 0 or posy > GetInfo (280) then
			check (SetCursor ( 11))   -- X cursor
		else
			check (SetCursor ( 1))   -- hand cursor
		end -- if
	end
end -- dragmove

function dragrelease(flags, hotspot_id)
end -- dragrelease
function mousedown(flags, hotspot_id)
    if hotspot_id == "z_body" then
		startx, starty = WindowInfo (win, 14), WindowInfo (win, 15)
    end
end
function mouseup(flags, hotspot_id)
    if hotspot_id:match("^[nesw]+$") then
        Execute("l "..hotspot_id)
	elseif flags == 16 then
        if hotspot_id:match("[A-R]") and  room_sequence[1] then
            if room_sequence[1] ~= hotspot_id then
                get_shortest_path(med_rooms, room_sequence[#room_sequence] or false, hotspot_id)
            end
        elseif hotspot_id:match("exit_nw") then
            if get_shortest_path(med_rooms, room_sequence[#room_sequence] or false, "A") then
                Execute("nw")
            end
        elseif hotspot_id:match("exit_se") then
            if get_shortest_path(med_rooms, room_sequence[#room_sequence] or false, "R") then
                Execute("se")
            end
        end
    elseif hotspot_id:match("[A-R]") and #room_sequence and flags == 32 then
        if med_rooms[room_sequence[#room_sequence]].exit_rooms[hotspot_id] then
            if med_rooms[room_sequence[#room_sequence]].normalized[med_rooms[room_sequence[#room_sequence]].exit_rooms[hotspot_id]] then
                Execute("l "..med_rooms[room_sequence[#room_sequence]].exit_rooms[hotspot_id])
            end
        end
    elseif flags == 80 and room_sequence[1] == hotspot_id then
        Send("b")
    end
end

function mouseover(flags, hotspot_id)
    if room_sequence[1] then
        if med_rooms[room_sequence[1]].exit_rooms then
            if med_rooms[room_sequence[1]].exit_rooms[hotspot_id] then
                if med_rooms[room_sequence[1]].normalized[med_rooms[room_sequence[1]].exit_rooms[hotspot_id]] then
                    move_dir = med_rooms[room_sequence[1]].normalized[med_rooms[room_sequence[1]].exit_rooms[hotspot_id]]
                    print_medina(room_sequence[1])
                end
            end
        end
    end
end

function cancelmouseover(flags, hotspot_id)
    if room_sequence[1] then
        if med_rooms[room_sequence[1]].exit_rooms then
            if med_rooms[room_sequence[1]].exit_rooms[hotspot_id] then
                if med_rooms[room_sequence[1]].normalized[med_rooms[room_sequence[1]].exit_rooms[hotspot_id]] then
                    move_dir = false
                    print_medina(room_sequence[1])
                end
            end
        end
    end
end
--------------------------------------------------------------------------------
--   INSTALL AND SAVE
--------------------------------------------------------------------------------
function OnPluginInstall ()
end

function OnPluginEnable ()
	WindowShow (win,  true)
end

function OnPluginDisable()
	WindowShow (win,  false)
end

function OnPluginClose ()
	WindowShow (win,  false)
end

function OnPluginSaveState ()
	SetVariable ("med_rooms", 
               "med_rooms = " .. serialize.save_simple (med_rooms))
end -- function OnPluginSaveState
--------------------------------------------------------------------------------
--   START EXECUTION HERE
--------------------------------------------------------------------------------
require "tprint"
require "serialize"

--load saved variables  
assert (loadstring (GetVariable ("med_rooms") or "")) ()
if not med_rooms then load_med_rooms() end

-- load dummy window

win = "medina_map" .. GetPluginID ()
WindowCreate (win, 0, 0, 0, 0, miniwin.pos_center_all, 0, ColourNameToRGB("black"))

--load timers
for room, v in pairs(med_rooms) do
    set_expiration_timer(med_rooms, room)
end

--load font
font_size = 14
WindowFont (win, "f", "Dina", font_size, false, false, false, false)
font_height = WindowFontInfo (win, "f", 1)
font_width = WindowTextWidth (win, "f", "0")  -- width of text

--define window properties
WIN_WIDTH = 300
WIN_HEIGHT = 300

mw_buffer_x, mw_buffer_y, map_width, map_height, block_x, block_y, room_width, room_height, exit_width, exit_height = get_map_measurments(WIN_WIDTH, WIN_HEIGHT)

--load window
window_pos_x = tonumber(GetVariable("window_pos_x"))
window_pos_y = tonumber(GetVariable("window_pos_y"))
WindowCreate (win, 0, 0, WIN_WIDTH, WIN_HEIGHT, miniwin.pos_center_all, 0, ColourNameToRGB("gray"))
if (type(window_pos_x) == "number") and (type(window_pos_x) == "number") then
	WindowPosition(win, window_pos_x, window_pos_y, 0, 2)
end

--load hotspots
create_hotspots(med_rooms)
WindowAddHotspot(win, "z_body",  -- draggable 
     0, 0, WIN_WIDTH, WIN_HEIGHT, 
     "",   -- MouseOver
     "",   -- CancelMouseOver
     "mousedown",
     "cancelmousedown", 
     "mouseup", 
    "Left-click to drag!",  -- tooltip text
     1, 0)  -- hand cursor
WindowDragHandler(win, "z_body", "dragmove", "dragrelease", 0)

room_sequence = {}
move_dir = false

--load images
file_path = (GetPluginInfo (GetPluginID (), 6)):match("^(.*\\).*$")

local directions = {"n", "ne", "e", "se", "s", "sw", "w", "nw"}
for _, v in ipairs(directions) do
    WindowCreate(win.."copy_from", 0, 0, exit_width-4, exit_height-4, miniwin.pos_center_all, 0, ColourNameToRGB("black"))
    WindowLoadImage (win.."copy_from", v, file_path.."arrows\\"..v..".bmp")
    WindowDrawImage(win.."copy_from", v, 0, 0, exit_width-4, exit_height-4, 2)
    WindowImageFromWindow(win, v, win.."copy_from")
end

--to do:

--toggle normalization
--make resizable
--menu
--compatible with brief view

]]>
</script>

</muclient>				